# 第十章 接口

接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。

首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。



## 抽象类和方法

接口的目的是为它的派生类创建一个通用接口

Java 提供了一个叫做*抽象方法*的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法：

```java
abstract void f();复制ErrorOK!
```

包含抽象方法的类叫做*抽象类*。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。

```java
// interface/Basic.java
abstract class Basic {
    abstract void unimplemented();
}
```

创建抽象类对象编译器会报错

如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 **abstract** 关键字。

可以将一个不包含任何抽象方法的类指明为 **abstract**，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。

为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义

**private abstract** 被禁止了

## 接口创建

使用 **interface** 关键字创建接口

描述 Java 8 之前的接口更加容易，因为它们只允许抽象方法。

不用为方法加上 **abstract** 关键字

在 Java 8之前我们可以这么说：**interface** 关键字产生一个完全抽象的类，没有提供任何实现。

Java 8 允许接口包含默认方法和静态方法

接口同样可以包含属性，这些属性被隐式指明为 **static** 和 **final**。

接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable，而抽象类通常是类层次结构的一部分或一件事物的类型，如 String 或 ActionHero

接口中的方法必须被定义为 **public**

### 默认方法

**default** （switch/接口默认方法）

默认方法有时也被称为*守卫方法*或*虚拟扩展方法*。

### 多继承

Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。

多年后的现在，Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。

现在我们做些在 Java 8 之前不可能完成的事：结合多个源的实现。只要基类方法中的方法名和参数列表不同，就能工作得很好，否则会得到编译器错误：需要重写冲突的方法

```java
import java.util.*;

interface Jim1 {
    default void jim() {
        System.out.println("Jim1::jim");
    }
}

interface Jim2 {
    default void jim() {
        System.out.println("Jim2::jim");
    }
}

public class Jim implements Jim1, Jim2 {
    @Override
    public void jim() {
        Jim2.super.jim(); // 重点: 接口.super.方法名来重写冲突方法
    }

    public static void main(String[] args) {
        new Jim().jim();
    }
}
```

### 接口中的人静态方法

Java 8 允许在接口中添加静态方法

## 抽象类和接口

尤其是在 Java 8 引入 **default** 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：

| 特性                 | 接口                                                       | 抽象类                                   |
| -------------------- | ---------------------------------------------------------- | ---------------------------------------- |
| 组合                 | 新类可以组合多个接口                                       | 只能继承单一抽象类                       |
| 状态                 | 不能包含属性（除了静态属性，不支持对象状态）               | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法 和 抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 | 必须在子类中实现抽象方法                 |
| 构造器               | 没有构造器                                                 | 可以有构造器                             |
| 可见性               | 隐式 **public**                                            | 可以是 **protected** 或友元              |

抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。

有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。

## 完全解耦

将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。

### 多接口结合

将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。

## 使用继承拓展接口

将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。

通常来说，**extends** 只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。

### 结合接口时的命名冲突

当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况

## 接口适配

适配器模式

## 接口字段

因为接口中的字段都自动是 **static** 和 **final** 的，所以接口就成为了创建一组常量的方便的工具。

### 初始化接口中的字段

接口中定义的字段不能是“空 **final**"，但是可以用非常量表达式初始化

这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中

## 接口嵌套

接口可以嵌套在类或其他接口中

## 接口和工厂方法模式

接口是多实现的途径，而生成符合某个接口的对象的典型方式是*工厂方法*设计模式



